/*
 * pwm.c
 *
 *  Created on: Jul 28, 2023
 *      Author: Phong
 */

#include "pwm.h"

void pwmClockEnable(uint8_t pwmModule){
    SYSCTL->RCGCPWM |= (1U << pwmModule);
}

void gpioClockEnable(uint8_t port){
    SYSCTL->RCGCGPIO |= (1U << port);
}

void gpioClockDisable(uint8_t port){
    SYSCTL->RCGCGPIO &= ~(1U << port);
}

void pwmClockDivisorEnable(){
    SYSCTL->RCC |= (1U << 20);
}

void pwmClockDivisorDisable(){
    SYSCTL->RCC &= ~(1U << 20);
}

void pwmClockDivisorConfig(uint8_t divisor){
    SYSCTL->RCC &= ~(0b111U << 17);
    SYSCTL->RCC |= (divisor << 17);
}

void alternatePinConfig(GPIOA_Type *port, uint8_t pin, uint8_t alternateFunction){
    port->AFSEL |= (1U << pin); //enable alternate pin
    port->PCTL &= ~(0b1111U << (pin * 4)); // clear the bits of alternate pin config
    port->PCTL |= (alternateFunction << (pin * 4)); // set the bits of alternate pin config
    port->DEN |= (1U << pin); // enable digital function
}

void pwmConfig(uint32_t PWMn_BASE, uint8_t generator, uint8_t countMode, uint16_t loadValue){  
    __IO uint32_t *_n_CTL = (uint32_t *)(PWMn_BASE + 0x40UL * generator);
    __IO uint32_t *_n_LOAD = (uint32_t *)(PWMn_BASE + 0x50UL * generator);

//    if (countMode == 0){
//        *_n_CTL ~= (1U << 1); // count-down mode
//    }
//    else {
//        *_n_CTL |= (1U << 1); // count-up mode
//    }
}



